MiniGit Version Control System Project

Original Implementation

This project is a mini version control system that replicates some of the functionality of Git and GitHub. The project works when the user is in a directory that contains files that they want to create a repository with. The program will prompt the user with 6 different functions that it can choose from. The user should always start by initializing the repository, which will create a .minigit directory within the user's current directory and will also initialize a doulby and singly linked list that will keep track of the commits of this repository. The user will then be prompted again to choose a function. They can add a file, remove a file, commit their changes, and checkout the files within a previous commit. 

Project Backend Setup

The basis of this version control system is operated using a doubly linked list (DLL) and singly linked lists (SLL) attached to every DLL node. The DLL represents each commit that has been made within the repository. When the repository gets initialized a DLL is created and the first node is assigned with a commitID of 0 representing the first commit of the repository. The commit functions are represented by a DLL function because in order for the checkout function to work, the program must be able to access the previous and next functions within the linked list (more on that later). Within each DLL, there will be an attached SLL which will keep track of all the files that have been added to that commit version. If the user prompts a commit, the DLL will add a node, representing a new commit then wll copy all the contents of the SLL from the previous commit over tothe new commit in order to keep the user's progress. 

Functions and Functionality

  The user will be prompted a menu that will have a list of all the functinality of the program and will have to enter a number, 1-8 corresponding with which function they want to use. Here is a list respectively of all the functions and what they do.
  
    1) Init: This initializes a new repository for the user within the current directory that it is in. It will create a new directory called .minigit and will initialize a new DLL which will keep track of all the commits that will be made throughout the repository's history. The first DLL node will also be initialized and will include a commitID of 0, an initialized SLL which will keep track of all the files added to the respective commit, a commit message that will not be assigned until the user decides to commit, and previous and next pointers which will be null until a new commit is issued. This function also initializes a hash table which will be used to store each word of a commit message in order to see which words correspond to which commitID's. The hash table will have a length of 5 and won't have any values in it initially until a commit message has been made. This always has to be the first step in the program and can only be called once.
  
    2) add: This allows the user to add files to the repository. The files have to already exist within the current directory that they ran the program with. The user will be prompted to enter the name of the file they will want to add. The program will then check to see if a path exists within the current directory that includes the inputted file name. If a path does exist, then the program will create a new file node and will traverse the SLL to see if another file node has the same name (it will check the most recent commit version's SLL, so the program also traverses through the DLL). If it doesn't exist within the SLL then the program will add it to the end of the SLL. If it does exist within the SLL or doesnt exist within the directory then respective messages will be outputted to the user and the program will prompt the user to enter another file name to try. 
    
    3) rm: This function allows the user to remove a file from the current commit version. Similar to the add function, it will check to make sure that a path exists in the current directory with the file name entered. It will then check to see if the current SLL has a file node with the same name. If it does then the file node will be deleted. If not, a message will be prompted that a file with that name doesn't exist within the SLL.
    
    4) commit: This function lets the user commit their changes to the repository so all their files will be saved under a respective commit version. When the user prompts the commit function they will be prompted to enter a commit message which can be at max 3 words determined using a white space delimeter. Once they enter the message, the program will make sure it's 3 words or under and that the same commit message hasnt already been used. If the message fits the parameters, then it will be broken up into individual words and added to the hash table. Before the message is added to the hash table, the commit function will check to see if any changes have been made since the last commit. If no changes have been made, the program exits and prompts a message saying that the commit was unsuccessful. If files have been changed, then the function will traverse through every file node within the most recent DLL node (current stored commit) and will check to see if the current version of the file exists within the .minigit directory. If the file doesnt exist, that indicates that this file was newly added to the repository during the current commit so a deep copy of the file is created and stored in the .minigit directory with a version of 0. If the file already exists within .minigit and is the same version number as the current file in the SLL, then a function is called that compares the two files line by line.. 
